---
layout: post
title: Object Repository Extension to the Standard Repository Pattern
date: 2011-03-10
---
<p>I have found that there are often times that I use the same queries against an object set but I end up writing the same or very similar LINQ statements against my context. This however can be solved by use a object specific repository. Below is the implementation over Entity Framework 4.1 and the AdventureWorks sample.</p>
<p>&nbsp;</p>
<p>We start with a plain console application and add a EntityContext folder.</p>
<p><a href="/images/image_34.png"><img style="background-image: none; border-bottom: 0px; border-left: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top: 0px; border-right: 0px; padding-top: 0px" title="image" src="/images/image_thumb_34.png" border="0" alt="image" width="244" height="56" /></a></p>
<p>Then we add new item ADO.NET Entity Data Model &ndash; Name it AdventureWorks.edmx. Use the wizard to connect to the local database for AdventureWorks. Then we add another Folder for our Repository Implementations. This is going to follow the patterns discussed in the <a href="http://www.devlinliles.com/post/Repository-and-Interface-Re-use-between-Databases.aspx" target="_blank">Repository patterns</a> post and <a href="http://www.devlinliles.com/post/Separating-POCO-and-Context-in-EF-40.aspx" target="_blank">POCO separation</a> posts.</p>
<p>using System;   <br />using System.Data.Objects;    <br />using System.Linq;    <br />using ObjectRepository.EntityContext;</p>
<p>namespace ObjectRepository.Repository   <br />{    <br />&nbsp;&nbsp;&nbsp; public class EntityFrameworkRepository : IRepository    <br />&nbsp;&nbsp;&nbsp; {    <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; private readonly ObjectContext _context;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public EntityFrameworkRepository(ObjectContext context)   <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {    <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _context = context;    <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public IQueryable&lt;T&gt; AsQueryable&lt;T&gt;() where T : class   <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {    <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return _context.CreateObjectSet&lt;T&gt;();    <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void SaveChanges()   <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {    <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _context.SaveChanges();    <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void Delete&lt;T&gt;(T item) where T : class   <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {    <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _context.DeleteObject(item);    <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void Add&lt;T&gt;(T item) where T : class   <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {    <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _context.CreateObjectSet&lt;T&gt;().AddObject(item);    <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void Attach&lt;T&gt;(T item) where T : class   <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {    <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _context.CreateObjectSet&lt;T&gt;().Attach(item);    <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void Detach&lt;T&gt;(T item) where T : class   <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {    <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _context.Detach(item);    <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }    <br />&nbsp;&nbsp;&nbsp; }    <br />}</p>
<p>This gives us the base to use, and we could use it as is.</p>
<p>using System;   <br />using System.Collections.Generic;    <br />using System.Linq;    <br />using System.Text;    <br />using ObjectRepository.EntityContext;    <br />using ObjectRepository.Repository;</p>
<p>namespace ObjectRepository   <br />{    <br />&nbsp;&nbsp;&nbsp; class Program    <br />&nbsp;&nbsp;&nbsp; {    <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static void Main(string[] args)    <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {    <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IRepository repository = new EntityFrameworkRepository(new AdventureWorksEntities());</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var longRunningProducts = repository.AsQueryable&lt;Product&gt;().Where(x =&gt; x.DaysToManufacture &gt; 3);   <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }    <br />&nbsp;&nbsp;&nbsp; }    <br />}</p>
<p>If we have to use the same long running products query a few times it is going to get old typing it and we have no control over the magic &ldquo;3&rdquo;. So how about we wrap a Product specific Repository.</p>
<p>using System.Linq;   <br />using ObjectRepository.EntityContext;</p>
<p>namespace ObjectRepository.Repository   <br />{    <br />&nbsp;&nbsp;&nbsp; public class ProductRepository : IProductRepository    <br />&nbsp;&nbsp;&nbsp; {    <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; private readonly IRepository _repository;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public ProductRepository(IRepository repository)   <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {    <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _repository = repository;    <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public IQueryable&lt;Product&gt; GetLongRunningProducts()   <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {    <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return _repository.AsQueryable&lt;Product&gt;().Where(x =&gt; x.DaysToManufacture &gt; 3);    <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }    <br />&nbsp;&nbsp;&nbsp; }    <br />}</p>
<p>namespace ObjectRepository.Repository   <br />{    <br />&nbsp;&nbsp;&nbsp; public interface IProductRepository    <br />&nbsp;&nbsp;&nbsp; {    <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IQueryable&lt;Product&gt; GetLongRunningProducts();    <br />&nbsp;&nbsp;&nbsp; }    <br />}</p>
<p>Then our usage becomes this&hellip;</p>
<p>using System;   <br />using System.Collections.Generic;    <br />using System.Linq;    <br />using System.Text;    <br />using ObjectRepository.EntityContext;    <br />using ObjectRepository.Repository;</p>
<p>namespace ObjectRepository   <br />{    <br />&nbsp;&nbsp;&nbsp; class Program    <br />&nbsp;&nbsp;&nbsp; {    <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static void Main(string[] args)    <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {    <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IRepository repository = new EntityFrameworkRepository(new AdventureWorksEntities());    <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IProductRepository productRepository = new ProductRepository(repository);    <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var longRunningProducts = productRepository.GetLongRunningProducts();    <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }    <br />&nbsp;&nbsp;&nbsp; }    <br />}</p>
<p>&nbsp;</p>
<p>Now no matter where you use the long running products you have the same result, no one has to remember the magic &ldquo;3&rdquo; and if it changes it only changes once. This will also allow you to wrap the queries in unit test and integration tests for performance but that is another post.</p>
<p>&nbsp;</p>
<p>Source Code is <a href="http://www.devlinliles.com/downloads/ObjectRepository.zip" target="_blank">here</a></p>
