---
layout: post
title: Composing Complex Queries with LINQ to Entities
date: 2011-04-29
---
<p>We have all had those times where we have had to build chains on complex where statements, with several OR / AND operations. These make LINQ queries look really complex and most of the time need to be reused in several places. To clean this up and give us the ability to compose complex queries on the fly from say a UI filter or something similar give the following a try.</p>  <p>public class Test   <br />&#160;&#160;&#160; {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; public void Testing()    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; Expression&lt;Func&lt;Product, bool&gt;&gt; isRed = c1 =&gt; c1.Color == &quot;Red&quot;;    <br />     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; Expression&lt;Func&lt;Product, bool&gt;&gt; isCheap = c2 =&gt; c2.StandardCost &lt; 10.0m;    <br />     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; Expression&lt;Func&lt;Product, bool&gt;&gt; isClothing = c3 =&gt; c3.Class == &quot;Clothing&quot;;    <br />     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; Expression&lt;Func&lt;Product, bool&gt;&gt; isAcceptable = Utility.BuildOrElse(isRed, isCheap, isClothing);    <br />     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; IQueryable&lt;Product&gt; products = null;    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; var query = products.Where(isAcceptable);    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }    <br />     <br />&#160;&#160;&#160; }    <br />     <br />&#160;&#160;&#160; public class ParameterRebinder : ExpressionVisitor    <br />&#160;&#160;&#160; {    <br />     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; private readonly Dictionary&lt;ParameterExpression, ParameterExpression&gt; map;    <br />     <br />     <br />     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; public ParameterRebinder(Dictionary&lt;ParameterExpression, ParameterExpression&gt; map)    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {    <br />     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; this.map = map ?? new Dictionary&lt;ParameterExpression, ParameterExpression&gt;();    <br />     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }    <br />     <br />     <br />     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; public static Expression ReplaceParameters(Dictionary&lt;ParameterExpression, ParameterExpression&gt; map, Expression exp)    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {    <br />     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; return new ParameterRebinder(map).Visit(exp);    <br />     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }    <br />     <br />     <br />     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; protected override Expression VisitParameter(ParameterExpression p)    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {    <br />     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; ParameterExpression replacement;    <br />     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (map.TryGetValue(p, out replacement))    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; {    <br />     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; p = replacement;    <br />     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }    <br />     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; return base.VisitParameter(p);    <br />     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }    <br />     <br />&#160;&#160;&#160; }    <br />     <br />&#160;&#160;&#160; public static class Utility    <br />&#160;&#160;&#160; {    <br />     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; public static Expression&lt;T&gt; Compose&lt;T&gt;(this Expression&lt;T&gt; first, Expression&lt;T&gt; second, Func&lt;Expression, Expression, Expression&gt; merge)    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {    <br />     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; // build parameter map (from parameters of second to parameters of first)    <br />     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; var map = first.Parameters.Select((f, i) =&gt; new { f, s = second.Parameters[i] }).ToDictionary(p =&gt; p.s, p =&gt; p.f);    <br />     <br />     <br />     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; // replace parameters in the second lambda expression with parameters from the first    <br />     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; var secondBody = ParameterRebinder.ReplaceParameters(map, second.Body);    <br />     <br />     <br />     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; // apply composition of lambda expression bodies to parameters from the first expression&#160; <br />     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; return Expression.Lambda&lt;T&gt;(merge(first.Body, secondBody), first.Parameters);    <br />     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }    <br />     <br />     <br />     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; public static Expression&lt;Func&lt;T, bool&gt;&gt; And&lt;T&gt;(this Expression&lt;Func&lt;T, bool&gt;&gt; first, Expression&lt;Func&lt;T, bool&gt;&gt; second)    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {    <br />     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; return first.Compose(second, Expression.And);    <br />     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }    <br />     <br />     <br />     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; public static Expression&lt;Func&lt;T, bool&gt;&gt; Or&lt;T&gt;(this Expression&lt;Func&lt;T, bool&gt;&gt; first, Expression&lt;Func&lt;T, bool&gt;&gt; second)    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {    <br />     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; return first.Compose(second, Expression.Or);    <br />     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }    <br />     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; public static Expression&lt;Func&lt;T, bool&gt;&gt; OrElse&lt;T&gt;(this Expression&lt;Func&lt;T, bool&gt;&gt; first, Expression&lt;Func&lt;T, bool&gt;&gt; second)    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {    <br />     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; return first.Compose(second, Expression.Or);    <br />     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }    <br />     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; public static Expression&lt;Func&lt;T, bool&gt;&gt; BuildAnd&lt;T&gt;(params Expression&lt;Func&lt;T, bool&gt;&gt;[] conditions)    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; return conditions.Aggregate&lt;Expression&lt;Func&lt;T, bool&gt;&gt;, Expression&lt;Func&lt;T, bool&gt;&gt;&gt;(null, (current, expression) =&gt; current == null ? expression : current.And(expression));    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }    <br />     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; public static Expression&lt;Func&lt;T, bool&gt;&gt; BuildOr&lt;T&gt;(params Expression&lt;Func&lt;T, bool&gt;&gt;[] conditions)    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; return conditions.Aggregate&lt;Expression&lt;Func&lt;T, bool&gt;&gt;, Expression&lt;Func&lt;T, bool&gt;&gt;&gt;(null, (current, expression) =&gt; current == null ? expression : current.Or(expression));    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }    <br />     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; public static Expression&lt;Func&lt;T, bool&gt;&gt; BuildOrElse&lt;T&gt;(params Expression&lt;Func&lt;T, bool&gt;&gt;[] conditions)    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; return conditions.Aggregate&lt;Expression&lt;Func&lt;T, bool&gt;&gt;, Expression&lt;Func&lt;T, bool&gt;&gt;&gt;(null, (current, expression) =&gt; current == null ? expression : current.OrElse(expression));    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }    <br />     <br />&#160;&#160;&#160; }    <br /></p>  <p>Adapted and added to from</p> <a title="http://blogs.msdn.com/b/meek/archive/2008/05/02/linq-to-entities-combining-predicates.aspx" href="http://blogs.msdn.com/b/meek/archive/2008/05/02/linq-to-entities-combining-predicates.aspx">http://blogs.msdn.com/b/meek/archive/2008/05/02/linq-to-entities-combining-predicates.aspx</a>
